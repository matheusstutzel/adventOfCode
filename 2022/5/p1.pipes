def @@input: "    [D]    
[N] [C]    
[Z] [M] [P]
 1   2   3 

move 1 from 2 to 1
move 3 from 1 to 3
move 2 from 2 to 1
move 1 from 1 to 2";

def convert(s):
  s:itermap()|>map(key,value:seq);
  
def apply(s,m):
  loop(m->count#, m->from#, m->to#, s)|>:convert;

def loop(c, f, t, s):
(0,c,f,t,s):unfold( fun(j,c,f,t,s):innerLoop(j,c,f,t,s));
 
def innerLoop(j, c,f,t,s):
  def @@should:j<c;
  def @@r: (s:map + newmap(t,  (s[f][0],):seq+ (s[t]:seq) ) + newmap(f, s[f]:seq:skip(1))):convert;
  @@should? (@@r, (j+1,c,f,t, @@r)), null;


def process(i, s):
  def @@should: i<len(mov);
  def @@r:  @@should?apply(s,(mov:seq)[i]), null;
  @@should?( @@r,(i+1, @@r)), null;

=> at the end 
=> @for @@input:split("\n")  as line
=>@set line=="" as readingCrane
=> set(line) as part every (readingCrane)
=> @set count():overall() == 1? "crane","movement" as group
=> map(group, part) as m
=> m + newmap("crane", m["crane"]|>@filter(_:contains("["))|>:list)
=> @yield 
=> @set (crane|>_$|> (:len:range|>((^_)[_] as a, _//4+1 as b)|>@filter(a>='A' and a<='Z')))|>@chain|>map(b, list(a)) as state
=>@set  movement:seq|> _$regex("move (?<count>[0-9]+) from (?<from>[0-9]+) to (?<to>[0-9]+)")|>list(_) as mov
=> @set (0,state):unfold(fun(a,b): process(a,b))|>last(_) as p, apply(state, (mov:seq)[0]):convert:apply((mov:seq)[1])
--=> p[len(p)-1]:itermap()|>map(key,value:seq)



--+ newmap(move->to, s[move->to]+s[move->from][0]) 
--+ newmap(move->from, s[move->from]:skip(1)

            
